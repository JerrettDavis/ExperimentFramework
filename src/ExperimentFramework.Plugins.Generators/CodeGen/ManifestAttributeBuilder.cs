using System.Collections.Generic;
using System.Linq;
using System.Text;
using ExperimentFramework.Plugins.Generators.Models;

namespace ExperimentFramework.Plugins.Generators.CodeGen;

/// <summary>
/// Builds the generated source code containing assembly attributes for the plugin manifest.
/// </summary>
internal static class ManifestAttributeBuilder
{
    /// <summary>
    /// Generates the source code for plugin manifest assembly attributes.
    /// </summary>
    public static string Build(
        AssemblyInfoModel assemblyInfo,
        ManifestConfigModel? config,
        IReadOnlyList<PluginImplementationModel> implementations)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("// Generated by ExperimentFramework.Plugins.Generators");
        sb.AppendLine();
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Determine plugin metadata
        var pluginId = config?.Id ?? assemblyInfo.AssemblyName;
        var pluginName = config?.Name ?? assemblyInfo.AssemblyName;
        var pluginVersion = assemblyInfo.Version;
        var description = config?.Description;
        var isolationMode = config?.IsolationMode ?? "Shared";
        var sharedAssemblies = config?.SharedAssemblies ?? [];
        var supportsHotReload = config?.SupportsHotReload ?? true;

        // Generate PluginManifestAttribute
        sb.AppendLine($"[assembly: global::ExperimentFramework.Plugins.Manifest.PluginManifestAttribute(");
        sb.AppendLine($"    \"{EscapeString(pluginId)}\",");
        sb.AppendLine($"    Name = \"{EscapeString(pluginName)}\",");
        sb.AppendLine($"    Version = \"{EscapeString(pluginVersion)}\",");
        if (description is not null)
        {
            sb.AppendLine($"    Description = \"{EscapeString(description)}\",");
        }
        sb.AppendLine($"    SupportsHotReload = {(supportsHotReload ? "true" : "false")})]");
        sb.AppendLine();

        // Generate PluginIsolationAttribute
        sb.AppendLine($"[assembly: global::ExperimentFramework.Plugins.Manifest.PluginIsolationAttribute(");
        sb.AppendLine($"    Mode = global::ExperimentFramework.Plugins.Abstractions.PluginIsolationMode.{isolationMode}");
        if (sharedAssemblies.Length > 0)
        {
            sb.Append($",    SharedAssemblies = new string[] {{ ");
            sb.Append(string.Join(", ", sharedAssemblies.Select(a => $"\"{EscapeString(a)}\"")));
            sb.AppendLine(" }");
        }
        sb.AppendLine(")]");
        sb.AppendLine();

        // Group implementations by interface
        var serviceGroups = implementations
            .Where(i => !i.IsExcluded && i.ServiceInterfaces.Length > 0)
            .SelectMany(impl => impl.ServiceInterfaces.Select(iface => (Interface: iface, Impl: impl)))
            .GroupBy(x => x.Interface)
            .ToList();

        // Generate PluginServiceAttribute for each interface
        foreach (var group in serviceGroups)
        {
            var interfaceName = group.Key;
            var impls = group.Select(x =>
            {
                var alias = x.Impl.ExplicitAlias ?? AliasGenerator.GenerateAlias(x.Impl.ClassName);
                // Store as "FullTypeName:alias"
                var typeName = x.Impl.FullTypeName;
                // Remove "global::" prefix if present
                if (typeName.StartsWith("global::"))
                    typeName = typeName.Substring(8);
                return $"{typeName}:{alias}";
            }).ToList();

            sb.AppendLine($"[assembly: global::ExperimentFramework.Plugins.Manifest.PluginServiceAttribute(");
            sb.AppendLine($"    InterfaceName = \"{EscapeString(interfaceName)}\",");
            sb.Append($"    Implementations = new string[] {{ ");
            sb.Append(string.Join(", ", impls.Select(i => $"\"{EscapeString(i)}\"")));
            sb.AppendLine(" })]");
            sb.AppendLine();
        }

        return sb.ToString();
    }

    private static string EscapeString(string value)
    {
        return value
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\r", "\\r")
            .Replace("\n", "\\n");
    }
}
